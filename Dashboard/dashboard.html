<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>MyKY</title>
    <style>
      body {
        position: relative;
        margin: 0;
        padding: 0;
        height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        font-family: Arial, sans-serif;
        overflow: hidden;
        background-image: url("../resources/Imgs/parchment_BG.jpg");
        background-size: cover;
        background-position: center;
      }
      h1 {
        margin: 20px 0 0 0;
        text-align: center;
        font-size: 2em;
        z-index: 5;
      }
      .map-container {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        top: -140px;
        max-width: 2200px;
        width: 100%;
        box-sizing: border-box;
        padding: 30px;
      }
      #map {
        width: 100%;
        height: 70vh;
      }
      #control-panel {
        position: absolute;
        top: 20px;
        left: 20px;
        background: linear-gradient(145deg, rgba(240, 240, 240, 0.95) 0%, rgba(255, 255, 255, 0.9) 100%);
        border: 5px solid;
        border-image: linear-gradient(to right, #A9A9A9, #C0C0C0, #A9A9A9) 1;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 4px 15px rgba(169, 169, 169, 0.15);
        z-index: 10;
      }
      #control-panel button {
        display: block;
        width: 100%;
        margin-bottom: 10px;
        padding: 8px 12px;
        background: #f0f0f0;
        border: 1px solid #ddd;
        border-radius: 4px;
        cursor: pointer;
      }
      #control-panel button:last-child {
        margin-bottom: 0;
      }
      #control-panel button:hover {
        background: #e0e0e0;
      }
      #kill-app-btn {
        background-color: red; /* Red background */
        color: black; /* Black text */
        font-weight: bold; /* Bold text */
      }
      #kill-app-btn:hover {
        background-color: darkred;
      }
      #compass {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 200px;
        height: 300px;
        object-fit: cover;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        z-index: 10;
      }
      #heraldic_shield {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 200px;
        height: 300px;
        object-fit: cover;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        z-index: 10;
      }
      
      #properties-panel {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 300px;
        max-height: 60vh;
        background: linear-gradient(145deg, rgba(240, 240, 240, 0.95) 0%, rgba(255, 255, 255, 0.9) 100%);
        border: 5px solid;
        border-image: linear-gradient(to right, #A9A9A9, #C0C0C0, #A9A9A9) 1;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 4px 15px rgba(169, 169, 169, 0.15);
        z-index: 10;
        overflow-y: auto;
      }
      
      #properties-panel h3 {
        margin: 0 0 10px 0;
        text-align: center;
        color: #333;
      }
      
      .property-item {
        background: rgba(255, 255, 255, 0.8);
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        margin-bottom: 8px;
        font-size: 0.9em;
      }
      
      .property-price {
        font-weight: bold;
        color: #2c5aa0;
      }
      
      .property-location {
        color: #666;
        font-size: 0.8em;
      }
      
      .property-details {
        color: #888;
        font-size: 0.7em;
        margin-top: 4px;
      }
      
      #load-properties-btn {
        width: 100%;
        padding: 8px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 10px;
      }
      
      #load-properties-btn:hover {
        background: #45a049;
      }
      
      #properties-count {
        text-align: center;
        font-size: 0.8em;
        color: #666;
        margin-bottom: 10px;
      }

    </style>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MyKY Dashboard</title>
    <!-- Add any necessary CSS links or styles here -->
    <script src="mapdata.js"></script>
    <script src="countymap.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        // Function to load external modal HTML
        function loadModalContent(url, callback) {
          fetch(url)
            .then(response => response.text())
            .then(html => {
              const modalContainer = document.createElement('div');
              modalContainer.innerHTML = html;
              document.body.appendChild(modalContainer);
    
              // Call the callback function after the modal content has been added to the DOM
              if (callback) callback(modalContainer);
            })
            .catch(error => console.error('Error loading modal content:', error));
        }
    
        // General function to set up modal handling for a button
        function setupModal(buttonId, modalUrl, prefix, title, content = null, additionalCallback = null) {
          document.getElementById(buttonId).addEventListener('click', function() {
            // Load the modal content dynamically
            loadModalContent(modalUrl, function(modalContainer) {
              // Open modal function
              const openModal = function(title, content) {
                const modalOverlay = document.getElementById(`${prefix}modal-overlay`);
                const modalTitle = document.getElementById(`${prefix}modal-title`);
                
                if (modalOverlay) {
                  modalTitle.textContent = title;
                  // Only update content if provided, otherwise keep existing content from HTML
                  if (content) {
                    const modalContent = document.getElementById(`${prefix}modal-content`);
                    modalContent.innerHTML = content;
                  }
                  modalOverlay.classList.add('active');
                }
              };
    
              // Close modal function
              const closeModal = function() {
                const modalOverlay = document.getElementById(`${prefix}modal-overlay`);
                if (modalOverlay) {
                  modalOverlay.classList.remove('active');
                }
              };
    
              // Attach event listeners for close
              const modalClose = modalContainer.querySelector(`#${prefix}modal-close`);
              if (modalClose) {
                modalClose.addEventListener('click', closeModal);
              }
    
              const modalOverlay = modalContainer.querySelector(`#${prefix}modal-overlay`);
              if (modalOverlay) {
                modalOverlay.addEventListener('click', function(e) {
                  if (e.target === modalOverlay) {
                    closeModal();
                  }
                });
              }
    
              // Run additional callback if provided (e.g., for Kill Protocol's terminate button)
              if (additionalCallback) {
                additionalCallback(modalContainer, closeModal); // Pass closeModal function
              }
    
              // Open the modal after it is fully loaded
              openModal(title, content);
            });
          });
        }
    
        // Additional setup for Scraper Dashboard modal (attach handlers when injected)
        const scraperDashboardAdditionalSetup = function(modalContainer) {
          const initiateBtn = modalContainer.querySelector('#initiate-scrape-btn');
          const statusOutput = modalContainer.querySelector('#status-output');
          const resultsDiv = modalContainer.querySelector('#scrape-results');
          const outputContent = modalContainer.querySelector('#output-content');
          const refreshBtn = modalContainer.querySelector('#refresh-status-btn');
          const closeBtn = modalContainer.querySelector('.modal-close-btn');

          if (initiateBtn) {
            initiateBtn.addEventListener('click', async function() {
              initiateBtn.disabled = true;
              initiateBtn.textContent = 'Scraping...';
              if (statusOutput) statusOutput.innerHTML = '<p>Initiating scrape...</p>';
              try {
                const response = await fetch('http://127.0.0.1:5001/api/initiate-scrape', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({})
                });
                const data = await response.json().catch(() => ({ success: false, error: 'Invalid JSON response' }));
                if (data && data.success) {
                  if (statusOutput) statusOutput.innerHTML = '<p>Scrape initiated successfully!</p>';
                  if (outputContent) outputContent.textContent = 'Scraping sites\n' + new Date().toLocaleString();
                  if (resultsDiv) resultsDiv.style.display = 'block';
                } else {
                  if (statusOutput) statusOutput.innerHTML = `<p>Error: ${(data && data.error) || 'Unknown error'}</p>`;
                  if (resultsDiv) resultsDiv.style.display = 'block';
                }
              } catch (error) {
                if (statusOutput) statusOutput.innerHTML = `<p>Connection error: ${error.message}</p>`;
                console.error('Scrape initiation failed:', error);
              } finally {
                initiateBtn.disabled = false;
                initiateBtn.textContent = 'Initiate Scrape Manually';
              }
            });
          }

          if (refreshBtn) {
            refreshBtn.addEventListener('click', function() {
              if (statusOutput) statusOutput.innerHTML = '<p>Status refresh not implemented yet.</p>';
            });
          }

          if (closeBtn) {
            closeBtn.addEventListener('click', function() {
              const modalOverlay = document.getElementById('scraper-dashboard-modal-overlay');
              if (modalOverlay) modalOverlay.classList.remove('active');
            });
          }
        };

        // Setup for other modals
        setupModal('sort-counties-btn', 'sortCountiesModal.html', 'sort-counties-', 'Sort Counties');
        setupModal('sort-properties-btn', 'sortPropertiesModal.html', 'sort-properties-', 'Sort Properties');
        setupModal('scraper-dashboard-btn', 'scraperDashboardModal.html', 'scraper-dashboard-', 'Scraper Dashboard', null, scraperDashboardAdditionalSetup);
        //setupModal('scraper-dashboard-btn', 'scraperDashboardModal.html', 'scraper-dashboard-', 'Scraper Dashboard');
        
        // Additional setup for Kill Protocol's terminate button and ESC handling
        const killAdditionalSetup = function(modalContainer, closeKillModal) {
          // Store the close function for Kill Protocol
          window.killProtocolClose = closeKillModal;
    
          const terminateButton = document.getElementById('terminateButton');
          if (terminateButton) {
            console.log('Terminate button found, attaching listener');
    
            terminateButton.addEventListener('click', async () => {
              console.log('Terminate button clicked! Starting POST to /Kill');
    
              const button = terminateButton;
    
              button.disabled = true;
              button.textContent = 'TERMINATE';
    
              // Sequence of status IDs in termination order
              const statusOrder = [
                { checkbox: 'checkbox-python', progress: 'progress-python', textId: 'status-python' },
                { checkbox: 'checkbox-chrome', progress: 'progress-chrome', textId: 'status-chrome' },
                { checkbox: 'checkbox-chromedriver', progress: 'progress-chromedriver', textId: 'status-chromedriver' },
                { checkbox: 'checkbox-port5000', progress: 'progress-port5000', textId: 'status-port5000' },                
                { checkbox: 'checkbox-port5001', progress: 'progress-port5001', textId: 'status-port5001' },
                { checkbox: 'checkbox-dotnet', progress: 'progress-dotnet', textId: 'status-dotnet' },
                { checkbox: 'checkbox-mykyweb', progress: 'progress-mykyweb', textId: 'status-mykyweb' }
              ];
    
              // Animate each status sequentially
              statusOrder.forEach((status, index) => {
                setTimeout(() => {
                  console.log(status);  // Debug: Ensure this is logging correctly for port5001

                  const checkbox = document.getElementById(status.checkbox);
                  const progressSpan = document.getElementById(status.progress);
                  const statusP = document.getElementById(status.textId);
    
                  if (checkbox && !checkbox.checked) {
                    checkbox.checked = true;
                  }
    
                  if (progressSpan && statusP) {
                    let currentPercent = 0;
                    let dots = '';
    
                    const interval = setInterval(() => {
                      currentPercent += 10;
                      dots += '.';
    
                      progressSpan.textContent = `[${currentPercent}%]`;
                      const textNode = statusP.childNodes[2];
                      if (textNode) {
                        textNode.textContent = textNode.textContent.replace(/\.{3,}$/, '') + dots;
                      }
    
                      if (currentPercent >= 100) {
                        clearInterval(interval);
                        progressSpan.textContent = '[100%]';
    
                        const audio = new Audio('../Resources/Audio/printDataLine.mp3');
                        audio.play().catch(error => console.log('Audio play failed:', error));
                      }
                    }, 200);
                  }
                }, index * 150);
              });
    
              // Delay the POST call by 4200ms
              setTimeout(async () => {
                try {
                  const response = await fetch('/Kill', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                  });
    
                  console.log('Response status:', response.status);
    
                  if (!response.ok) {
                    const error = await response.text();
                    throw new Error(`Server error (${response.status}): ${error}`);
                  }
    
                  const data = await response.json();
    
                  // Use the stored close function
                  setTimeout(() => {
                    if (window.killProtocolClose) {
                      window.killProtocolClose();
                    }
                  },
                  12,600); 
                  //4200);
                } catch (error) {
                  console.error('Fetch error:', error);
    
                  if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
                    console.log('Server shutdown detected; closing tab');
                    setTimeout(() => {
                      if (window.close) {
                        window.close();
                      } else {
                        window.location.href = 'about:blank';
                      }
                    }, 1000);
                  }
                } finally {
                  button.disabled = false;
                  button.textContent = 'TERMINATE';
                }
              }, 4200);
            });
          } else {
            console.error('Terminate button (#terminateButton) not found in modal');
          }
        };
    
        // Setup for Kill Protocol Modal (with additional terminate logic)
        setupModal('kill-app-btn', 'killProtocolModal.html', 'kill-protocol-', 'Kill Protocol Initiated', null, killAdditionalSetup);
        
        // Properties panel functionality
        const loadPropertiesBtn = document.getElementById('load-properties-btn');
        const refreshPropertiesBtn = document.getElementById('refresh-properties-btn');
        const propertiesList = document.getElementById('properties-list');
        const propertiesCount = document.getElementById('properties-count');
        
        // Make loadProperties function globally accessible
        window.loadProperties = async function() {
          if (loadPropertiesBtn) {
            loadPropertiesBtn.click();
          }
        };
        
        // Add refresh button functionality
        if (refreshPropertiesBtn) {
          refreshPropertiesBtn.addEventListener('click', function() {
            if (loadPropertiesBtn) {
              loadPropertiesBtn.click();
            }
          });
        }
        
        if (loadPropertiesBtn) {
          loadPropertiesBtn.addEventListener('click', async function() {
            loadPropertiesBtn.disabled = true;
            loadPropertiesBtn.textContent = 'Loading...';
            propertiesList.innerHTML = '<p>Loading properties...</p>';
            
            try {
              const response = await fetch('http://localhost:5000/api/property');
              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }
              const properties = await response.json();
              
              if (properties.length === 0) {
                propertiesList.innerHTML = '<p>No properties found in database.</p>';
                propertiesCount.textContent = '0 properties';
              } else {
                propertiesCount.textContent = `${properties.length} properties`;
                propertiesList.innerHTML = properties.map(property => `
                  <div class="property-item">
                    <div class="property-price">${property.price}</div>
                    <div class="property-location">${property.fullAddress || property.address}</div>
                    <div class="property-details">
                      ${property.acres} • ${property.county}<br>
                      ${property.site} • Listed: ${new Date(property.listedDate).toLocaleDateString()}
                    </div>
                  </div>
                `).join('');
              }
            } catch (error) {
              console.error('Error loading properties:', error);
              propertiesList.innerHTML = `<p>Error loading properties: ${error.message}</p>`;
              propertiesCount.textContent = 'Error';
            } finally {
              loadPropertiesBtn.disabled = false;
              loadPropertiesBtn.textContent = 'Load Properties';
            }
          });
        }
    
        // Enhanced Escape key handler that works for ALL modals including Kill Protocol
        document.addEventListener('keydown', function(e) {
          if (e.key === 'Escape') {
            // Check for any active modals using the general class selector
            const activeOverlays = document.querySelectorAll('[id$="-modal-overlay"].active');
            activeOverlays.forEach(overlay => {
              overlay.classList.remove('active');
            });
    
            // Specifically handle Kill Protocol modal
            const killOverlay = document.getElementById('kill-protocol-modal-overlay');
            if (killOverlay && killOverlay.classList.contains('active')) {
              killOverlay.classList.remove('active');
            }
    
            // Use stored close function if available
            if (window.killProtocolClose) {
              window.killProtocolClose();
            }
          }
        });
      });
    </script>
  </head>
  <body>
    <div id="control-panel">
      <h2>Control Panel</h2>
      <button id="sort-counties-btn">Sort Counties</button>
      <button id="sort-properties-btn">Sort Properties</button>
      <button id="scraper-dashboard-btn">Scraper Dashboard</button>
      <button id="kill-app-btn">Kill Protocol</button>
    </div>
    
    <div id="properties-panel">
      <h3>Properties Database</h3>
      <button id="load-properties-btn">Load Properties</button>
      <button id="refresh-properties-btn" style="margin-left: 5px; padding: 4px 8px; background: #2196F3; color: white; border: none; border-radius: 3px; cursor: pointer;">🔄 Refresh</button>
      <div id="properties-count"></div>
      <div id="properties-list"></div>
    </div>
    <h1>MyKY</h1>
    <div class="map-container">
      <div id="map"></div>
    </div>
    <img id="compass" alt="Top right image" src="../resources/Imgs/compass.png"/>
    <img id="heraldic_shield" alt="Heraldic Shield of MyKY" src="../resources/Imgs/heraldic_shield.png"/>
    <!-- Modal Structures will be loaded dynamically -->
  </body>
</html>